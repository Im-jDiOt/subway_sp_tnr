최단 경로 탐색 프로젝트에서
김수현 학생은 A*, 김은주 학생은 TNR, 장승호 학생은 다익스트라 파트를 
나누어 진행했습니다.

먼저, UCS와 다익스트라입니다.
공통점과 기능 차이는 이렇고
설계상 차이점은 추적 방식에 순방향, 역방향을 둔 것입니다.

prioirty queue를 minheap으로 구현했습니다. 최솟값 찾기 편하므로.

1단계 기본적인 다익스트라를 실험해보았습니다. 
분기와, 분기 환승 시 3분을 추가했습니다.

2단계에서 C로 구현된 heapq 라이브러리를 사용하여 속도를 높였습니다. 
UCS를 도입하여 비교하였습니다.

3단계에서는 급행 시스템을 도입했습니다. 급행 환승시 1분 소요됩니다.
노드는 (노선명, 타입, 역이름) 형태의 튜플로 구성하여, 같은 역이라도 
급행/일반 여부와 노선을 구분할 수 있도록 설계했습니다.
노선 건설 등에 이런 기법이 어떻게 적용되는가
직관을 얻을 수 있었습니다.

4단계에서는 데이터 관리와 로직을 개선하였습니다. 호선, 급행 등의 속성과 역을 
통합 hash table로 생성하여
가독성과 유지보수성을 높였습니다
새로운 역이나 노선을 추가할 때, 조건문을 일일이 수정할 필요 없이 
all_station_properties만 갱신하면 됩니다
이미지는 최단경로를 시각화한 것입니다. 

다음은 A* 알고리즘입니다.
알고리즘은 휴리스틱 함수가 존재합니다.휴리스틱만 잘 동작한다면 빠르다는 장점을 갖고 있습니다.  이번 프로젝트에서 사용한 휴리스틱은 총 4가지로

1. 역 이름 일치 기반 2.  환승 예측 기반 3. 노선 내 거리 기반 . 4. 혼합 휴리스틱 입니다.

역 이름 일치 기반의 경우 휴리스틱 함수는 이렇습니다
다음은 환승 예측입니다. 두 역이 어떤 노선들을 공유하는지에 따라 환승을  예측하였습니다. 노선 내 인덱스 기반 거리입니다. 정거장 수를 이용하여 계산하였습니다.  같은 노선 내에서 인덱스 차이를 거리로 추정하였고 다른 노선이면 환승 패널티인 2를 발생시켰습니다. 마지막으로 세 가지 휴리스틱을 적절히 조합한 복합 휴리스틱입니다.하지만 계산 비용이 커져 매우 느렸습니다, 안전성 외 장점이 있진 않았습니다.  또 앙상블 알고리즘도 최단경로를 찾기에 안전하지만 계산비용이 컸습니다.

다음은 BFS입니다. visited, dist, prev를 이용하였습니다. 중복 탐색을 방지하고, 현재까지 도달한  최소 비용을 관리하고, prev를 이용해 최단 경로를 추적하였습니다. 

다음은 TNR 알고리즘입니다.

그림에서 주황색으로 표시된 환승 노드 사이를 간선으로만 이었지만, 실제로는 평균 5.28개의 노드가 존재합니다. 그러나 이는 실제 경로 탐색에는 의미가 없습니다. 따라서 이를 단순화하여 환승 노드들만으로 최단 경로를 탐색한 후, 입력으로 들어온 역에서 환승역까지의 거리를 더해서 최종 경로를 결정할 수 있다고 생각할 수 있습니다. 이는 265개의 노드, 283개의 간선이 존재하는 그래프에서의 최단 경로 탐색을 transfer node들로만 이루어진 39개의 노드, 57개의 간선이 존재하는 그래프에서의 최단 경로 탐색으로 단순화할 수 있으므로, 합리적이라고 판단됩니다.

이에 대한 구현은 각 부분을 추상화하여 환승역 간의 APSP 결과를 해시 테이블에 저장하고, input 역이 주어지면 인접 환승역만 잘 구해서 인접 환승역과 해당 역까지의 경로를 반환받는 방식으로 진행하였습니다. 그래서 최종적으로 이러한 공식(𝑑𝑖𝑠𝑡(𝑥,𝑦)=𝑑𝑖𝑠𝑡(𝑥,𝑡1)+𝑑𝑖𝑠𝑡(𝑡1,𝑡2)+𝑑𝑖𝑠𝑡(𝑡2, 𝑦))을 통해 전체 경로를 구할 수 있게 됩니다.

그러나 만약 최단경로가 환승역을 지나지 않는다면 돌아가는 길을 안내하게 됩니다. 이미지의 케이스(ppt 슬라이드 39)가 그 한 예시가 됩니다.

케이스를 보다 체계적으로 정의해보면, input node x, y 각각은 다음과 같은 3가지 형태가 가능하고, 각 형태의 쌍들에 대해서 case0\~case3이 존재합니다. 먼저 case0일 경우 현재 역, 거리 0을 반환합니다. case1과 case2의 위 두 케이스에서는 슬라이스로 경로를 반환합니다. 맨 아래 케이스는 슬라이스할 경우와 빨강 파랑 환승역의 APSP 결과 중에서 최단 경로를 반환합니다. case3은 일반적인 TNR 상황으로, APSP 최단 경로를 반환합니다. (슬라이드 40~43)

각 케이스에 대한 수도 코드도 작성하였고, 다이어그램도 시각화하였습니다. 각 케이스 조합에 대해서 꼼꼼히 테스트를 진행하였고, 이후 1000개 무작위 조합에 대해서도 테스트를 진행하여 통과하였습니다. 통과의 기준은 같은 그래프에 대해 networkx 패키지의 다익스트라와 비교하는 것으로 삼았습니다.

이때 APSP 알고리즘으로 다익스트라와 다이얼을 사용해보았는데, 다익스트라가 성능이 더 좋았습니다. 그 이유로는 환승 그래프의 가중치 분포가 2에 몰려있고 전반적으로 sparse하게 분포되어 있기 때문이라고 생각합니다.

마지막으로 벤치마킹 결과입니다.
데이터셋마다 해당 데이터셋을 사용하는 알고리즘끼리 비교하도록 테스트 진행했습니다. 테스트 데이터셋은 같은 데이터셋에 대해 테스트를 진행하는 알고리즘일 경우 모두 동일한 테스트 데이터셋으로 진행하도록 하였고 이는 랜덤 1000쌍 페어로 구성되어 진행됐습니다. 도표의 시간은 A star, Dijkstra, ucs는 1000회 수행 시간 평균으로, tnr의 경우 사전 계산 시간 1회 및 1000회 수행 시간의 합의 평균입니다. 같은 색상일 경우 같은 데이터셋을 사용했음을 의미합니다. 최종적으로 TNR w/ dijkstra가 0.027ms(0.000027s)로 가장 빨랐음을 알 수 있습니다. 그 이유로는 1) 환승역만 고려한 그래프에서 apsp 알고리즘을 사용해 문제를 단순화시킴 2) 이후 경로는 apsp 알고리즘 결과 해시 테이블 접근 시간 O(1) + 인풋역부터 환승역까지의 슬라이싱 O(n') (이때 n'은 5.28 이하의 값 기대 가능) 으로 특히 많은 쿼리가 들어왔을 때 효과적으로 작동할 수 있도록 구현되었기 때문이라 생각합니다. 

